1. 안드로이드에서 View의 크기를 정의하는 데 사용되는 px, dp, sp 단위의 차이점과 각각 언제 사용하는 것이 적절할까요?

- px: 해상도,밀도에 따라 크기가 달라짐 / 커스텀 뷰나 고정된 사이즈가 꼭 필요한 경우에 사용 가능 ( 주로 1px 테두리, 구분선 등 정밀한 픽셀 제어가 필요한 경우에만 제한적으로 사용)
- dp: 디바이스 밀도에 따라 실제 픽셀 수로 변환됨 / 대부분의 경우 사용 (레이아웃의 크기, 마진, 패딩 등 대부분의 View 크기 정의에 사용)
- sp: 사용자가 글꼴 크기 키워도 자동 적용 / 레이아웃의 크기, 마진, 패딩 등 대부분의 View 크기 정의에 사용

2. Activity 간에 데이터를 전달하는 데 Intent를 사용합니다. 기본 데이터 타입(int, String 등)은 Intent의 Extra를 통해 쉽게 전달할 수 있습니다. 그렇다면 기본 타입이 아닌 객체는 어떻게 전달해야 할까요? 이때 자바의 원시 타입이 객체가 아니기 때문에 발생하는 Boxing의 개념도 함께 설명해주세요. (레벨 1 복습)

- Parcelable 인터페이스 구현
- Serializable 인터페이스 구현
- JSON 직렬화(Gson 등)

- 자바에서 원시 타입(primitive type)은 객체가 아니기 때문에 컬렉션이나 객체 전달 등 객체 타입이 필요한 상황에서 사용할 수 없습니다. 이를 해결하기 위해 **Boxing**이 나옴
- **Boxing**: 원시 타입 값을 해당하는 Wrapper 클래스 객체로 변환하는 과정입니다. 예를 들어, **`int`**를 **`Integer`**로, **`double`**을 **`Double`**로 변환합니다

3. 화면 회전과 같은 구성 변경이 발생하면 Activity는 기본적으로 어떻게 동작하며, 이로 인해 어떤 문제가 발생할 수 있을까요? 또, 이 외에 어떤 경우에 Activity 소멸로 인해 데이터 유지를 고민해야 할까요? (이전 수업 생명 주기 복습)

- **`onPause`** -> **`onStop`** -> **`onDestroy`** -> **`onCreate`** -> **`onStart`** -> **`onResume`** 로 동작
    
    Destroy 되므로 데이터가 날아갈 수 있는 문제 발생
    
- 백그라운드 상태에 있을 때 메모리가 부족해지면 뷰가 제거될 수 있음
    
    saveInstance나 restoreInstance 를 이용해서 데이터 유지를 할 수 있음
    

4. 복잡한 UI를 가진 앱이 성능 저하를 겪는 주요 이유는 무엇일까요? 특히 ListView와 같이 많은 수의 아이템을 표시하는 경우 성능 문제가 더 두드러지는 이유는 무엇일까요?
    - 과도한 UI 요소 및 복잡한 레이아웃
        - 뷰 계층이 너무 깊거나 복잡함
        - 불필요한 onDraw() 호출 또는 커스텀 뷰에서의 비효율적인 그리기
    - 실시간 데이터 처리 및 무거운 연산의 UI 스레드 차단 ( 복잡한 계산, 대량의 데이터 파싱, 이미지처리 등)
    - 불필요한 기능 및 과도한 데이터 로딩

- 모든 아이템을 한 번에 렌더링
- UI 스레드의 과부하
- 불필요한 UI 요소 및 컬럼 과다
- 실시간 렌더링 및 이벤트 처리

5. ListView를 효율적으로 만들기 위해 ViewHolder 패턴을 사용하는 이유는 무엇이며, 이 패턴을 적용하면 메모리 사용량과 성능에 어떤 개선 효과를 가져올 수 있을까요?
   재사용 가능한 뷰를 캐시하고, 이를 재사용하여 뷰를 재생성하는 비용을 줄일 수 있음
