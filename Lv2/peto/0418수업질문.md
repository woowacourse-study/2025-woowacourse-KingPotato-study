### 🛎️ 2025.04.18 Jame 수업 질문
<hr/>

### 1. px, dp, sp 단위의 차이점과 각각 언제 사용하는 것이 적절할까요?
 
1. PX(pixel)
- 화면을 구성하는 최소 단위
- 화면 밀도와 무관하게 1픽셀은 화면의 1픽셀과 일치
- 기기의 화면 밀도에 적합하게 조정되지 않는다.

2. DPI(Dots Per Inch)
- 1인치에 들어가는 픽셀
- 개수가 많을수록 고밀도이며 안드로이드에서 주요 DPI는 아래와 같다.
    - ldpi : 120dpi
    - mdpi : 160dpi(기본)
    - hdpi : 240dpi
    - xhdpi : 320dpi
    - xxhdpi : 480dpi
    - xxxhdpi : 640dpi
- 안드로이드 기준 DPI : 160dpi
    - 이 경우 밀도 독립단위(DP)와 픽셀이 같은 크기를 갖는다.
    - ex) 160dp에서 1dp는 1px이 된다.
3. DP(density-independent pixel, 밀도 독립적 픽셀)
- 여러 화면에서 일관된 시각적 크기를 보장하기 위해 사용
- 160dpi 기준 1dp는 항상 기기 화면의 1/160 인치다.
- 기기의 화면이 고밀도일 때는 더 많은 수의 화면을 채우기 위해
4. SP (scale-independent pixel, 크기 독립적 픽셀)
- 텍스트 크기를 정의하는 데 특별히 사용
- 기기의 시스템 설정에서 사용자가 선호하는 텍스트 크기를 고려
- 1 sp는 1 dp와 동일하지만, 사용자의 글꼴 크기 기본 설정도 고려

### 2. Activity 간에 데이터를 전달하는 데 Intent를 사용합니다. 기본 타입이 아닌 객체는 어떻게 전달해야 할까요? 이때 자바의 원시 타입이 객체가 아니기 때문에 발생하는 Boxing의 개념도 함께 설명해주세요. (레벨 1 복습)

- 직렬화 라이브러리를 사용해 객체의 원시 타입 프로퍼티를 `byte-stream`으로 변조하는 과정
- ObjectOutputStream과 ObjectInputStream을 통해 직렬화 및 역직렬화를 수행한다.
- 직렬화를 수행하는 메서드 ObjectOuputStream.writeObject(Object obj) 인자가 Object이기 때문에 원시 타입을 Boxing 해주어야 한다.

직렬화는 `Serialization, Parcelable`을 사용해 구현할 수 있다.

1. `Serialization`
- `Seralizable` 은 자바 표준 인터페이스로 `Marker Interface`로서 단순히 `implemen`t하는 것만으로도 JVM에게 직렬화가 가능하다는 것을 알려주기 때문에 사용하는게 매우 쉽다.
- 객체가 역직렬화될 때 객체 생성자는 호출되지 않는다.

3. Android Parcelable

- 안드로이드 의존성을 가짐 직렬화에 쓰일 수 있는 인터페이스
- 직렬화 처리 방법을 개발자가 직접 명시하여 작성할 수 있도록 메서드를 제공
- Serializable과 달리 자동으로 처리되지 않으며 이에 따른 Reflection도 존재하지 않음

> 박싱 : 원시 타입(primitive) 을 객체로 감싸는 것
```
val n: int? = 0
```
- 자바엔 코틀린의 널을 허용하는 타입이 존재하지 않습니다.
- 때문에 코틀린 코드를 자바로 디컴파일 하면 널을 허용하는 원시 타입은 자바의 Wrapper Type으로 감싸지며 이를 **박싱**이라고 합니다.
 - 위 예제 코드처럼 널을 허용하는 정수 타입의 경우 자바의 Interger Type으로 박싱됩니다.

### 3.화면 회전과 같은 구성 변경이 발생하면 Activity는 기본적으로 어떻게 동작하며, 이로 인해 어떤 문제가 발생할 수 있을까요? 또, 이 외에 어떤 경우에 Activity 소멸로 인해 데이터 유지를 고민해야 할까요? (이전 수업 생명 주기 복습)

configuration change 발생시 다음 순서대로 생명주기 콜백이 호출된다.
+ onStop
+ onDestroy
+ onCreate
+ onStart
+ onResume

화면이 완전히 파괴 되었다 재생성되기 때문에 `onSaveInstanceState` 를 사용해 Bundle에 값을 저장 후 onCreate의 인자로 넘어오는 savedInstanceState을 통해 복원한다
```
// 복원
override fun onCreate(savedInstanceState: Bundle?) {
  val data = savedInstanceState.getInt(KEY_COUNT)
}

// 저장
override fun onSaveInstanceState(outState: Bundle) {
    super.onSaveInstanceState(outState)

    val data = 1
    outState.putInt(KEY_COUNT, data)
}
```
